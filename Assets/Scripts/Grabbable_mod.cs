using System;
using Oculus.Interaction.Throw;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Pool;

namespace Oculus.Interaction
{
    public class Grabbable_mod : PointableElement, IGrabbable, ITimeConsumer
    {
        [SerializeField, Interface(typeof(ITransformer))]
        [Optional(OptionalAttribute.Flag.AutoGenerated)]
        private UnityEngine.Object _oneGrabTransformer = null;

        [SerializeField, Interface(typeof(ITransformer))]
        [Optional(OptionalAttribute.Flag.AutoGenerated)]
        private UnityEngine.Object _twoGrabTransformer = null;

        [SerializeField]
        [Optional(OptionalAttribute.Flag.AutoGenerated)]
        private Transform _targetTransform;

        [SerializeField, Min(-1)]
        private int _maxGrabPoints = -1;

        [Header("Physics")]
        [SerializeField, Optional(OptionalAttribute.Flag.DontHide)]
        private Rigidbody _rigidbody;
        [SerializeField]
        private bool _kinematicWhileSelected = true;
        [SerializeField]
        private bool _throwWhenUnselected = true;

        public static event Action<GameObject> OnGrabbed;
        public static event Action<GameObject> OnMoved;
        public static event Action<GameObject> OnReleased;

        public int MaxGrabPoints
        {
            get
            {
                return _maxGrabPoints;
            }
            set
            {
                _maxGrabPoints = value;
            }
        }

        public Transform Transform => _targetTransform;
        public List<Pose> GrabPoints => _selectingPoints;

        private Func<float> _timeProvider = () => Time.time;
        public void SetTimeProvider(Func<float> timeProvider)
        {
            _timeProvider = timeProvider;
            if (_throw != null)
            {
                _throw.SetTimeProvider(timeProvider);
            }
        }

        private ITransformer _activeTransformer = null;
        private ITransformer OneGrabTransformer;
        private ITransformer TwoGrabTransformer;

        private ThrowWhenUnselected _throw;

        private bool _isKinematicLocked = false;

        #region Editor
        protected virtual void Reset()
        {
            _rigidbody = this.GetComponent<Rigidbody>();
        }
        #endregion

        protected override void Awake()
        {
            base.Awake();
            OneGrabTransformer = _oneGrabTransformer as ITransformer;
            TwoGrabTransformer = _twoGrabTransformer as ITransformer;
        }

        protected override void Start()
        {
            this.BeginStart(ref _started, () => base.Start());

            if (_targetTransform == null)
            {
                _targetTransform = transform;
            }

            if (_oneGrabTransformer != null)
            {
                this.AssertField(OneGrabTransformer, nameof(OneGrabTransformer));
                OneGrabTransformer.Initialize(this);
            }

            if (_twoGrabTransformer != null)
            {
                this.AssertField(TwoGrabTransformer, nameof(TwoGrabTransformer));
                TwoGrabTransformer.Initialize(this);
            }

            // Create missing defaults
            if (OneGrabTransformer == null && TwoGrabTransformer == null)
            {
                ITransformer transformer = GenerateTransformer();
                transformer.Initialize(this);
            }

            if (_rigidbody != null && _throwWhenUnselected)
            {
                _throw = new ThrowWhenUnselected(_rigidbody, this);
                _throw.SetTimeProvider(this._timeProvider);
            }

            this.EndStart(ref _started);
        }

        protected override void OnDisable()
        {
            if (_started)
            {
                EndTransform();
            }

            base.OnDisable();
        }

        protected virtual void OnDestroy()
        {
            if (_throw != null)
            {
                _throw.Dispose();
                _throw = null;
            }
        }

        private ITransformer GenerateTransformer()
        {
            ITransformer transformer = gameObject.AddComponent<GrabFreeTransformer>();
            this.InjectOptionalOneGrabTransformer(transformer);
            this.InjectOptionalTwoGrabTransformer(transformer);
            return transformer;
        }

        public override void ProcessPointerEvent(PointerEvent evt)
        {
            switch (evt.Type)
            {
                case PointerEventType.Select:
                    EndTransform();
                    break;
                case PointerEventType.Unselect:
                    ForceMove(evt);
                    EndTransform();
                    break;
                case PointerEventType.Cancel:
                    EndTransform();
                    break;
            }

            base.ProcessPointerEvent(evt);

            switch (evt.Type)
            {
                case PointerEventType.Select:
                    BeginTransform();
                    break;
                case PointerEventType.Unselect:
                    BeginTransform();
                    break;
                case PointerEventType.Move:
                    UpdateTransform();
                    break;
            }
        }

        protected override void PointableElementUpdated(PointerEvent evt)
        {
            UpdateKinematicLock(SelectingPointsCount > 0);

            base.PointableElementUpdated(evt);
        }

        private void UpdateKinematicLock(bool isGrabbing)
        {
            if (_rigidbody == null
                || !_kinematicWhileSelected)
            {
                return;
            }

            if (!_isKinematicLocked && isGrabbing)
            {
                _isKinematicLocked = true;
                _rigidbody.LockKinematic();
            }
            else if (_isKinematicLocked && !isGrabbing)
            {
                _isKinematicLocked = false;
                _rigidbody.UnlockKinematic();
            }
        }

        private void ForceMove(PointerEvent releaseEvent)
        {
            PointerEvent moveEvent = new PointerEvent(releaseEvent.Identifier,
                PointerEventType.Move, releaseEvent.Pose, releaseEvent.Data);
            ProcessPointerEvent(moveEvent);
        }

        // Whenever we change the number of grab points, we save the
        // current transform data
        private void BeginTransform()
        {
            // End the transform on any existing transformer before we
            // begin the new one
            EndTransform();

            int useGrabPoints = _selectingPoints.Count;
            if (_maxGrabPoints != -1)
            {
                useGrabPoints = Mathf.Min(useGrabPoints, _maxGrabPoints);
            }

            switch (useGrabPoints)
            {
                case 1:
                    _activeTransformer = OneGrabTransformer;
                    break;
                case 2:
                    _activeTransformer = TwoGrabTransformer;
                    break;
                default:
                    _activeTransformer = null;
                    break;
            }

            if (_activeTransformer == null)
            {
                return;
            }

            OnGrabbed?.Invoke(this.gameObject);
            _activeTransformer.BeginTransform();
        }

        private void UpdateTransform()
        {
            if (_activeTransformer == null)
            {
                return;
            }

            OnMoved?.Invoke(this.gameObject);
            _activeTransformer.UpdateTransform();
        }

        private void EndTransform()
        {
            if (_activeTransformer == null)
            {
                return;
            }
            OnReleased?.Invoke(this.gameObject);
            _activeTransformer.EndTransform();
            _activeTransformer = null;
        }

        #region Inject

        public void InjectOptionalOneGrabTransformer(ITransformer transformer)
        {
            _oneGrabTransformer = transformer as UnityEngine.Object;
            OneGrabTransformer = transformer;
        }

        public void InjectOptionalTwoGrabTransformer(ITransformer transformer)
        {
            _twoGrabTransformer = transformer as UnityEngine.Object;
            TwoGrabTransformer = transformer;
        }

        public void InjectOptionalTargetTransform(Transform targetTransform)
        {
            _targetTransform = targetTransform;
        }

        public void InjectOptionalRigidbody(Rigidbody rigidbody)
        {
            _rigidbody = rigidbody;
        }

        public void InjectOptionalThrowWhenUnselected(bool throwWehenUnselected)
        {
            _throwWhenUnselected = throwWehenUnselected;
        }

        public void InjectOptionalKinematicWhileSelected(bool kinematicWhileSelected)
        {
            _kinematicWhileSelected = kinematicWhileSelected;
        }

        #endregion

       private class ThrowWhenUnselected : ITimeConsumer, IDisposable
        {
            private Rigidbody _rigidbody;
            private IPointable _pointable;

            private Func<float> _timeProvider = () => Time.time;
            public void SetTimeProvider(Func<float> timeProvider)
            {
                _timeProvider = timeProvider;
            }

            private static IObjectPool<RANSACVelocity> _ransacVelocityPool = new ObjectPool<RANSACVelocity>(
                createFunc: () => new RANSACVelocity(8, 2, 2),
                collectionCheck: false,
                defaultCapacity: 2);

            private RANSACVelocity _ransacVelocity = null;

            private Pose _lastPose = Pose.identity;
            private float _lastTime = 0f;
            private bool _isHighConfidence = true;

            private int _selectorsCount = 0;

            /// <param name="rigidbody">The rigidbody to track velocity from and throw.</param>
            /// <param name="pointable">The IPointable indicating when the rigidbody is selected and unselected.</param>
            public ThrowWhenUnselected(Rigidbody rigidbody, IPointable pointable)
            {
                _rigidbody = rigidbody;
                _pointable = pointable;

                _pointable.WhenPointerEventRaised += HandlePointerEventRaised;
            }

            public void Dispose()
            {
                _pointable.WhenPointerEventRaised -= HandlePointerEventRaised;
            }

            private void AddSelection()
            {
                if (_selectorsCount++ == 0)
                {
                    Initialize();
                }
            }

            private void RemoveSelection(bool canThrow)
            {
                if (--_selectorsCount == 0)
                {
                    if (canThrow)
                    {
                        Process(true);
                        LoadThrowVelocities();
                    }
                    Teardown();
                }
                _selectorsCount = Mathf.Max(0, _selectorsCount);
            }

            private void HandlePointerEventRaised(PointerEvent evt)
            {
                switch (evt.Type)
                {
                    case PointerEventType.Select:
                        AddSelection();
                        break;
                    case PointerEventType.Move:
                        if (_selectorsCount > 0)
                        {
                            Process(false);
                            MarkFrameConfidence(evt.Identifier);
                        }
                        break;
                    case PointerEventType.Cancel:
                        RemoveSelection(false);
                        break;
                    case PointerEventType.Unselect:
                        MarkFrameConfidence(evt.Identifier);
                        RemoveSelection(true);
                        break;
                }
            }

            private void Initialize()
            {
                Pose rootPose = _rigidbody.transform.GetPose();
                float time = _timeProvider.Invoke();

                _ransacVelocity = _ransacVelocityPool.Get();
                _ransacVelocity.Initialize(rootPose, time);
            }

            private void Teardown()
            {
                _ransacVelocityPool.Release(_ransacVelocity);
                _ransacVelocity = null;
            }

            private void MarkFrameConfidence(int emitterKey)
            {
                if (!_isHighConfidence)
                {
                    return;
                }

                if (HandTrackingConfidenceProvider.TryGetTrackingConfidence(emitterKey, out bool isHighConfidence))
                {
                    if (!isHighConfidence)
                    {
                        _isHighConfidence = false;
                    }
                }
            }

            private void Process(bool forceSubmit)
            {
                float time = _timeProvider.Invoke();
                Pose pose = _rigidbody.transform.GetPose();

                if (time > _lastTime || forceSubmit)
                {
                    _isHighConfidence &= pose.position != _lastPose.position;
                    _ransacVelocity.Process(pose,
                        forceSubmit ? time : _lastTime,
                        _isHighConfidence);
                    _isHighConfidence = true;
                }

                _lastTime = time;
                _lastPose = pose;
            }

            private void LoadThrowVelocities()
            {
                _ransacVelocity.GetVelocities(out Vector3 velocity, out Vector3 torque);
                _rigidbody.velocity = velocity;
                _rigidbody.angularVelocity = torque;
            }

        }
    }
}
